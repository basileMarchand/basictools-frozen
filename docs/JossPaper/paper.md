---
title: 'BasicTools: a numerical simulation toolbox'
tags:
  - Python
  - C++
  - mesh
  - fields
  - finite elements
  - post-treatment
authors:
  - name: Felipe Bordeu^[corresponding author]
    orcid: 0000-0002-0640-5485
    affiliation: 1
  - name: Fabien Casenave
    orcid: 0000-0002-8810-9128
    affiliation: 1
  - name: Julien Cortial
    affiliation: 1
affiliations:
 - name: Safran Tech, Digital Sciences & Technologies Department, Rue des Jeunes Bois, Châteaufort, 78114 Magny-Les-Hameaux, France
   index: 1
date: 05 february  2023
bibliography: paper.bib

---

# Summary

Numerical simulations of physical phenomena can be computed by many (commercial/free) software packages, but despite the apparent variety, they rely on a relatively small set of operations during the preparation, exploitation and post-process of these simulations. For instance, the post-processing of physical fields are a common need, as well as handling and modifying meshes and fields. BasicTools is a Python library designed to address these supporting tasks. It features an efficient data model for meshes and field objects and input/output routines compatible with various formats. A finite element engine allows to assemble abstract variational formulations, take into account differential operators and integrate fields on volumes and surfaces.

BasicTools has been (and is actively being) used in artificial intelligence and model order reduction for physical problems [@ROM-net; @mca26010017; @UQindustrialDesign; @datatargetVAE], topology optimization [@nardoni], and material sciences [@pymicro] projects.

# Statement of need

Oftentimes in real-world simulation, data is obtained from various sources, each of them providing its own encoding format and data model. Every software package typically includes its own post-processing tool to explore the solutions calculated by the simulation engine. Generally the tool is tailored only for the data model generated by it own simulation engine, thus limiting interoperability and preventing to set up seamless workflows, for example passing fields from one simulation tool to another or aggregating all the generated data into one module for comparison and computation of Quantities of Interest. Typically common tasks must be routinely reimplemented, often with subtle variations. Une example of this problem the use of domain specific criterion (e.g. a degradation criteria for a high performance material). If the user change the simulation software he must reimplement the criteria in the framework of the new software, increasing the amount of work and the risk of introducing new bugs.

Our solution to theses concerns is BasicTools, which introduces a data model for meshes and related physical fields. This model can be populated using different readers and exported using various writers. Additionally, many algorithms are implemented on these meshes and physical fields, including mesh manipulation, a finite element engine and field projection operators. Notably no new mesh or solution format is forced upon the user: the goal is to handle existing data formats and offer common tasks and services on these data. This include the capacity of dealing with the integration point data (absent in others libraries our knowledge). The integration quadrature used by the simulation software can be imported and used to compute new integrals on partial differential equations and the computation of quantities of interest to help engineers in the decision making process. BasicTools was designed using a data centric approach (no low level objects) making it possible to do hight performance operations on meshes and fields using a hight level language (Python wiht Numpy). Additionally BasicTools contains tools to convert meshes to other "in-memory" formats (VTK [@VTK4], PyVista [@sullivan2019pyvista], MeshIO [@meshio], CGNS [@cgns], Gmsh [@gmsh] ). This make possible to mix (and reuse) treatments already available in other frameworks.

# State of the field

In the computational fluid dynamics community, the CFD General Notation System (CGNS) [@cgns] standard has been proposed for analysis data. In the solid mechanics community, to the author's knowledge, no such de facto standard exists. As far as meshes are concerned, one may consider MeshIO for converting between various file formats, or VTK for the manipulation of meshes, although it lacks some capabilities of tremendous value for the solid mechanics community (e.g. integration point data). The post-process of integration point data is something rarely address correctly by other tools. Most, if not all, the existent tool do the simple, but potentially dangerous approach, of extrapolate the integration point values to the nodes of the mesh or do the average in every cell, this can lead to the missinterpretation of the solution leading to wrong conclusions. Also there is only a few finite element engines allowing to assemble abstract variational formulations on arbitrary geometries (e.g. FreeFem++ [@freefempp] and FEniCS [@fenics] among others).

# Overview

BasicTools was designed with the intention of creating a set of canonical tools to work on meshes and fields.

The main features of the library are

- Meshes (in the module `Containers`):
  ConstantRectilinearMesh.py and UnstructuredMesh.py define the data model for constant rectilinear and unstructured mesh types. Unstructured meshes are efficient in the sense that elements are stored using only one array for each element type. Both mesh types can feature nodes and element tags. Many functions are available for creating, cleaning and modifying meshes. In particular, field projection operations enable to project fields defined on a mesh onto a set of points, using various methods and options, with respect to the location of the destination points being inside or outside the origin mesh (finite element interpolation, extrapolation, clamped evaluations, nearest neighbors, zero fill). Mesh morphing capabilities are also included.
- Filters (in the module `Containers`):
  Various types of `ElementFilter`s and `NodeFilter`s enable to handle subparts of the meshes by selecting element- and node-sets using threshold functions, tags, element types, element dimensionality and masks. Arbitrary filters can be combined using boolean operations (union, complementary...) to construct advanced filters on points and elements.
- A finite element engine (in the module `FE`):
  A general weak formulation engine able to integrate fields over any part of the considered mesh is available. The FE.FETools module contains specific functions for Lagrange P1 finite elements, including the computation of stiffness and mass matrices. The domain of integration is defined using `ElementFilter`s to make the integration domain flexible. Depending on the parameter of the integration, the result can be a matrix (e.g. tangent operator), a vector (e.g. right hand side term), or a scalar (e.g. volume, energy). Also P0 and P2 Lagrange finite element spaces are fully implemented and tested. The framework of BasicTools is non iso-parametric, meaning the user can write a weak formulation of a mix of P0, P1 and P2 fields on P1 or P2 meshes.
- Input/Output functions (in the module `IO`):
  Various readers (respectively, writers) for importing (exporting) meshes and solution fields from (to) the internal data model of BasicTools are available. See [BasicTools documentation](https://basictools.readthedocs.io/en/latest/_source/BasicTools.IO.html#submodules) for the complete list of supported files. Available formats include geo/geof (Z-set [@zset]), VTK, XDMF, SAMCEF, ABAQUS. The bridge with MeshIO brings extra import/export capabilities by wrapping the MeshIO readers/writers with the BasicTools API. The ABAQUS, and the SAMCEF solution (fields) readers depends on local installation of the respective software due to the proprietary format solution files.
- Implicit geometry engine (in the module `ImplicitGeometry`):
  The classes are used to define arbitrary subdomains using only implicit geometries (level-set function). Basic shapes (spheres, half-spaces, cylinders, cubes), transformations (symmetry, translation, rotation) as well as binary operators (union, difference, intersection) can be used to construct complex shapes. Then these shapes can be used to select elements (using an `ElementFilter`), or be evaluated on a point cloud (e.g. the points of a mesh) to explicitly construct the iso-zero surface.
- Linear Algebra functions (in the module `Linalg`):
  Some common operation on linear systems in the domain of finite element. A class for imposing constraints on minimization problems (boundary conditions), the user can choose between penalization, elimination, Lagrange multipliers and the Ainsworth [@AINSWORTH20016323] method. The submodule `LinearSolver` offers an abstraction layer for some linear solvers for sparse matrices. The available interface include the following solvers: cholesky of the sksparse module; factorized, CG, lsqr, gmres, lgmres of the scipy.sparse.linalg module; CG, LU, BiCGSTAB, SPQR of the C++ Eigen library; and the AMG solver of pyamg module.


The architecture of the library is described below.

```dox
BasicTools
├───Containers
│   │   UnstructuredMes
│   ┆   Filters
├───FE
│   ├───Fields
│   ├───Spaces
│   ├───...
│   │   FETools
│   ┆   Integration
├───IO
│   │   XdmfReader
│   ┆   XdmfWriter
├───ImplicitGeometry
│   ...
├───Linalg
┆   ...
```
</a>


The large majority of functions are illustrated in the same file where they are defined, in `CheckIntegrity` functions.

# Examples

We detail two examples illustrating some of the features mentioned in the previous section.
The complete examples can be found in the BasicTools documentation.[BasicTools documentation](https://basictools.readthedocs.io/en/latest/Examples.html).

## Pre/post deep learning

Classic deep learning algorithms relies on structured data (i.e. images in 2D) as input data. The finite element method offers the capacity to work on unstructured meshes to better capture the solution and to concentrate the computation effort only on the zones where precision is required. To be able to transfer the information for the physical simulation into a deep learning algorithm, a projection of the fields defined on an unstructured mesh into a rectilinear grid is required. The inverse is also necessary in the case the output of the deep learning algorithms generate the input data for a downstream finite element simulation on an arbitrary unstructured mesh.

In this example we demonstrate the use of BasicTools to transfer a field from a unstructured mesh to a structured grid and vice versa. To validate the operation the error on the final field is evaluated with respect to the original field.

![Example of a deep learning workflow coupled to a finit element simulator a) Initial field on a unstructured mesh, b) transferred field into a regular grid (projection step) c) inverse projection into the original unstructured mesh d) projection error on the unstructured mesh .\label{fig:DeepLearningPrepost}](DeepLearningPrepost.png)


## Mechanical analysis: Thick plate with 2 inclusions

Here we present a study case of a thick plate with 2 inclusions: one softer and the other stiffer than the base material. The plate is clamped on the left side with a applied negative pressure on the right side (blue arrows).  Then we compute the strain energy on only one inclusion. The linear elasticity PDE is solved using P1 Lagrange finite elements on a unstructured mesh.

![Analysis of a mechanical thick plate with two inclusions.\label{fig:TwoInclusions}](TwoInclusions_img1.png)


# References
